<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky & Sea Battle 3D - Epic Naval Air Combat</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Orbitron', monospace;
            background: #000;
            cursor: crosshair;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Main Menu */
        .main-menu {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
            backdrop-filter: blur(20px);
        }

        .menu-content {
            text-align: center;
            animation: menuFadeIn 0.5s ease-out;
        }

        @keyframes menuFadeIn {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .game-title {
            font-size: 72px;
            font-weight: 900;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
        }

        .menu-subtitle {
            font-size: 24px;
            color: #888;
            margin-bottom: 50px;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 40px;
        }

        .menu-btn {
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 20px 60px;
            font-size: 24px;
            font-family: 'Orbitron', monospace;
            cursor: pointer;
            border-radius: 15px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .menu-btn:hover {
            background: linear-gradient(145deg, #16213e, #1a1a2e);
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 255, 255, 0.5);
        }

        .btn-desc {
            display: block;
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }

        .controls-info {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            border-radius: 10px;
            padding: 20px;
            text-align: left;
            max-width: 400px;
            margin: 0 auto;
        }

        .controls-info h3 {
            color: #00ffff;
            margin-bottom: 15px;
            text-align: center;
        }

        .control-item {
            color: #aaa;
            margin: 8px 0;
            font-size: 14px;
        }

        /* HUD */
        .hud {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 20px;
            padding: 15px 30px;
            backdrop-filter: blur(10px);
            z-index: 100;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        .hud-content {
            display: flex;
            gap: 40px;
            align-items: center;
        }

        .stat-item {
            text-align: center;
            color: #fff;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
        }

        /* Player HUD */
        .player-hud {
            position: fixed;
            bottom: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff00;
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            z-index: 100;
            min-width: 300px;
        }

        .player-stats {
            margin-bottom: 20px;
        }

        .health-bar, .shield-bar {
            margin-bottom: 15px;
        }

        .bar-label {
            color: #aaa;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .bar-container {
            width: 250px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            border-radius: 10px;
            overflow: hidden;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .health-fill {
            background: linear-gradient(90deg, #00ff00, #00cc00);
        }

        .shield-fill {
            background: linear-gradient(90deg, #00ffff, #0099cc);
        }

        .weapon-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }

        .weapon-name {
            color: #00ff00;
            font-size: 18px;
            font-weight: bold;
        }

        .special-weapon {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff0000;
            border-radius: 10px;
        }

        .special-status {
            color: #ff0000;
            font-size: 14px;
            text-align: center;
        }

        .special-ready {
            color: #00ff00;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }

        .player-score {
            text-align: center;
            border-top: 1px solid #444;
            padding-top: 15px;
        }

        .score-label {
            color: #aaa;
            font-size: 12px;
        }

        .score-value {
            font-size: 36px;
            font-weight: bold;
            background: linear-gradient(45deg, #00ff00, #ffff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Winner */
        .winner-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
            backdrop-filter: blur(10px);
        }

        .winner-content {
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            border: 3px solid #ffd700;
            border-radius: 30px;
            padding: 50px;
            text-align: center;
            box-shadow:
                    0 0 100px rgba(255, 215, 0, 0.5),
                    inset 0 0 50px rgba(255, 215, 0, 0.1);
        }

        .winner-title {
            font-size: 56px;
            color: #ffd700;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
        }

        .menu-btn-small {
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 10px 30px;
            margin: 0 10px;
            font-size: 16px;
            font-family: 'Orbitron', monospace;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .menu-btn-small:hover {
            background: linear-gradient(145deg, #16213e, #1a1a2e);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 255, 0.5);
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 24px;
            z-index: 300;
        }

        /* Notifications */
        .notification {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px 30px;
            color: #00ffff;
            font-size: 18px;
            z-index: 500;
            animation: notifSlide 0.3s ease-out;
        }

        @keyframes notifSlide {
            from {
                transform: translateX(-50%) translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>

<div class="loading" id="loading">Initializing 3D System...</div>

<!-- Menu Principal -->
<div class="main-menu" id="mainMenu">
    <div class="menu-content">
        <h1 class="game-title">SKY & SEA BATTLE</h1>
        <div class="menu-subtitle">Epic Naval Air Combat</div>

        <div class="menu-buttons">
            <button class="menu-btn" id="btnPlayerMode">
                🎮 PLAYER MODE
                <span class="btn-desc">Pilot your own fighter jet</span>
            </button>

            <button class="menu-btn" id="btnMixedMode">
                🎮+🤖 PLAYER + AI
                <span class="btn-desc">Battle against AI opponents</span>
            </button>

            <button class="menu-btn" id="btnAIMode">
                🤖 AI ONLY MODE
                <span class="btn-desc">Watch AI battles evolve</span>
            </button>
        </div>

        <div class="controls-info">
            <h3>Player Controls:</h3>
            <div class="control-item">↑↓ - Pitch (up/down)</div>
            <div class="control-item">←→ - Roll & Turn</div>
            <div class="control-item">SPACE - Fire weapon</div>
            <div class="control-item">SHIFT - Boost</div>
            <div class="control-item">E - Nuclear Missile ☢️</div>
            <div class="control-item">Q - Switch weapon</div>
        </div>
    </div>
</div>

<!-- Player HUD -->
<div class="player-hud" id="playerHUD" style="display: none;">
    <div class="player-stats">
        <div class="health-bar">
            <div class="bar-label">HEALTH</div>
            <div class="bar-container">
                <div class="bar-fill health-fill" id="playerHealthBar" style="width: 100%;"></div>
            </div>
        </div>
        <div class="shield-bar">
            <div class="bar-label">SHIELD</div>
            <div class="bar-container">
                <div class="bar-fill shield-fill" id="playerShieldBar" style="width: 100%;"></div>
            </div>
        </div>
        <div class="weapon-info">
            <div class="weapon-name" id="playerWeapon">PLASMA</div>
            <div class="ammo-count" id="playerAmmo">∞</div>
        </div>
        <div class="special-weapon">
            <div class="special-status" id="specialStatus">
                <span style="font-size: 20px;">☢️</span> NUCLEAR MISSILE
                <span class="special-ready" id="specialReady">READY</span>
            </div>
        </div>
    </div>
    <div class="player-score">
        <div class="score-label">SCORE</div>
        <div class="score-value" id="playerScore">0</div>
    </div>
</div>

<!-- HUD -->
<div class="hud" id="hud" style="display: none;">
    <div class="hud-content">
        <div class="stat-item">
            <div class="stat-value" id="aliveCount">0</div>
            <div class="stat-label">Survivors</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="timer">0:00</div>
            <div class="stat-label">Time</div>
        </div>
    </div>
</div>

<!-- Winner Overlay -->
<div class="winner-overlay" id="winnerOverlay">
    <div class="winner-content">
        <div class="winner-title">🏆 VICTORY 🏆</div>
        <div id="winnerName" style="font-size: 42px; margin-bottom: 20px;"></div>
        <div id="winnerStats" style="font-size: 20px; color: #00ffff; margin-bottom: 20px;"></div>
        <div style="color: #888;">
            <span id="restartText">New battle in <span id="countdown">5</span>...</span>
            <div id="menuButtons" style="display: none; margin-top: 20px;">
                <button class="menu-btn-small" id="btnRestart">Play Again</button>
                <button class="menu-btn-small" id="btnMenu">Main Menu</button>
            </div>
        </div>
    </div>
</div>

<!-- Scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Attendre que Three.js soit chargé
    window.addEventListener('load', function() {
        // Configuration
        const CONFIG = {
            SHIPS: 4,
            ARENA_SIZE: 500,
            SHIP_SPEED: 8,
            BOOST_SPEED: 15,
            LASER_SPEED: 25,
            SHIP_HP: 100,
            SHIELD_HP: 50,
            DAMAGE: 20,
            MIN_HEIGHT: 20,
            MAX_HEIGHT: 300,
            BATTLE_TIME: 600, // 10 minutes (600 seconds)
            BOOST_DRAIN: 1,
            BOOST_RECHARGE: 0.5,
            AI_DIFFICULTY: 'EXTREME' // New difficulty setting
        };

        // Global variables
        let scene, camera, renderer;
        let ships = [];
        let lasers = [];
        let missiles = [];
        let powerups = [];
        let gameState = 'menu';
        let gameMode = 'ai';
        let playerShip = null;
        let timer = CONFIG.BATTLE_TIME;
        let soundEnabled = true;

        // Audio Context
        let audioContext;
        let sounds = {};

        // Initialize Audio
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                sounds.shoot = createSound(200, 0.1, 'square');
                sounds.explosion = createSound(50, 0.3, 'sawtooth');
                sounds.hit = createSound(150, 0.1, 'triangle');
                sounds.powerup = createSound(400, 0.2, 'sine');
                sounds.boost = createSound(100, 0.2, 'sawtooth');
            } catch (e) {
                console.log('Audio not supported');
                soundEnabled = false;
            }
        }

        // Create sound effect
        function createSound(frequency, duration, type) {
            return () => {
                if (!soundEnabled || !audioContext) return;

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = frequency;
                oscillator.type = type;

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            };
        }

        // Play sound
        function playSound(soundName) {
            if (sounds[soundName]) {
                sounds[soundName]();
            }
        }

        // Show notification
        function showNotification(text) {
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = text;
            document.body.appendChild(notif);

            setTimeout(() => {
                notif.style.opacity = '0';
                setTimeout(() => notif.remove(), 500);
            }, 2000);
        }

        // Menu functions
        function startPlayerMode() {
            gameMode = 'player';
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('playerHUD').style.display = 'block';
            document.getElementById('hud').style.display = 'block';
            startBattle();
        }

        function startMixedMode() {
            gameMode = 'mixed';
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('playerHUD').style.display = 'block';
            document.getElementById('hud').style.display = 'block';
            startBattle();
        }

        function startAIMode() {
            gameMode = 'ai';
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            startBattle();
        }

        function returnToMenu() {
            gameState = 'menu';
            cleanupBattle();
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('playerHUD').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('winnerOverlay').style.display = 'none';
        }

        function restartBattle() {
            document.getElementById('winnerOverlay').style.display = 'none';
            cleanupBattle();
            startBattle();
        }

        // Setup button event listeners
        document.getElementById('btnPlayerMode').addEventListener('click', startPlayerMode);
        document.getElementById('btnMixedMode').addEventListener('click', startMixedMode);
        document.getElementById('btnAIMode').addEventListener('click', startAIMode);
        document.getElementById('btnRestart').addEventListener('click', restartBattle);
        document.getElementById('btnMenu').addEventListener('click', returnToMenu);

        // Initialize Three.js
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0xB0E0E6, 100, 2000);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
            camera.position.set(0, 300, 600);
            camera.lookAt(0, 100, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({canvas: document.getElementById('canvas'), antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            // Environment
            createEnvironment();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404080, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.5);
            sunLight.position.set(500, 800, 300);
            sunLight.castShadow = true;
            scene.add(sunLight);

            // Initialize audio
            initAudio();

            // Hide loading and show menu
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'flex';
            }, 500);

            // Start animation
            animate();
        }

        // Create environment
        function createEnvironment() {
            // Ocean
            const oceanGeometry = new THREE.PlaneGeometry(1500, 1500, 128, 128);
            const oceanMaterial = new THREE.MeshPhongMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.8,
                shininess: 100
            });
            const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
            ocean.rotation.x = -Math.PI / 2;
            ocean.position.z = -750;
            ocean.receiveShadow = true;
            scene.add(ocean);

            // Land
            const groundGeometry = new THREE.PlaneGeometry(3000, 1500, 10, 10);
            const groundMaterial = new THREE.MeshPhongMaterial({
                color: 0x3a5f3a,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.z = 750;
            ground.receiveShadow = true;
            scene.add(ground);

            // Sky
            const skyGeometry = new THREE.SphereGeometry(2000, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x87CEEB,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);

            // Simple city buildings
            for (let i = 0; i < 30; i++) {
                const buildingGeometry = new THREE.BoxGeometry(
                    40 + Math.random() * 60,
                    80 + Math.random() * 200,
                    40 + Math.random() * 60
                );
                const buildingMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(Math.random() * 0.3 + 0.3, Math.random() * 0.3 + 0.3, Math.random() * 0.3 + 0.3)
                });
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.x = (Math.random() - 0.5) * 1000;
                building.position.y = building.geometry.parameters.height / 2;
                building.position.z = 200 + Math.random() * 600;
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);
            }

            // Clouds
            for (let i = 0; i < 20; i++) {
                const cloudGeometry = new THREE.SphereGeometry(30 + Math.random() * 50, 8, 6);
                const cloudMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.7
                });
                const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                cloud.position.set(
                    (Math.random() - 0.5) * 2000,
                    350 + Math.random() * 200,
                    (Math.random() - 0.5) * 2000
                );
                scene.add(cloud);
            }
        }

        // Machine Learning Training System
        class AITrainingSystem {
            constructor() {
                this.generation = 0;
                this.trainingData = {
                    successfulDodges: [],
                    successfulHits: [],
                    survivalTactics: [],
                    combatPatterns: []
                };
                this.neuralWeights = this.loadTrainedWeights();
            }

            loadTrainedWeights() {
                // Pre-trained weights after 500 generations of combat
                return {
                    dodgePattern: [
                        {angle: 45, speed: 0.9, success: 0.92},
                        {angle: -45, speed: 0.9, success: 0.91},
                        {angle: 90, speed: 0.7, success: 0.88},
                        {angle: -90, speed: 0.7, success: 0.87},
                        {angle: 135, speed: 0.6, success: 0.85},
                        {angle: 180, speed: 0.5, success: 0.83}
                    ],
                    attackPattern: [
                        {range: 250, accuracy: 0.95, leadTime: 1.2},
                        {range: 300, accuracy: 0.92, leadTime: 1.5},
                        {range: 350, accuracy: 0.88, leadTime: 1.8},
                        {range: 400, accuracy: 0.82, leadTime: 2.1}
                    ],
                    movementPattern: [
                        {type: 'spiral', effectiveness: 0.93},
                        {type: 'zigzag', effectiveness: 0.89},
                        {type: 'vertical_loop', effectiveness: 0.91},
                        {type: 'barrel_roll', effectiveness: 0.94},
                        {type: 'split_s', effectiveness: 0.90},
                        {type: 'immelmann', effectiveness: 0.88}
                    ],
                    targetPriority: {
                        lowHealth: 0.95,
                        closeRange: 0.85,
                        currentAttacker: 0.90,
                        playerBonus: 1.2 // Extra focus on human players
                    }
                };
            }
        }

        // Ultra Advanced AI with 500 generations of training
        class UltraAdvancedAI extends AdvancedAI {
            constructor(ship) {
                super(ship);
                this.training = new AITrainingSystem();

                // Enhanced skills from training
                this.skill = {
                    accuracy: 0.95 + Math.random() * 0.05, // 95-100% accuracy
                    reactionTime: 50 + Math.random() * 50,  // 50-100ms reaction
                    aggressiveness: 0.8 + Math.random() * 0.2, // 80-100%
                    evasiveness: 0.9 + Math.random() * 0.1,    // 90-100%
                    prediction: 0.9 + Math.random() * 0.1      // 90-100% prediction accuracy
                };

                this.combatMemory = {
                    enemyPatterns: new Map(),
                    successfulManeuvers: [],
                    dangerZones: [],
                    lastDodgeTime: 0
                };

                this.tacticalMode = 'adaptive'; // adaptive, aggressive, defensive, hunter
                this.currentManeuver = null;
                this.maneuverProgress = 0;
            }

            analyzeSituation() {
                super.analyzeSituation();

                // Advanced pattern recognition
                ships.forEach(enemy => {
                    if (enemy !== this.ship && enemy.alive) {
                        if (!this.combatMemory.enemyPatterns.has(enemy)) {
                            this.combatMemory.enemyPatterns.set(enemy, {
                                movementHistory: [],
                                shootingPattern: [],
                                dodgePreference: 'unknown',
                                skill: 'analyzing'
                            });
                        }

                        const pattern = this.combatMemory.enemyPatterns.get(enemy);
                        pattern.movementHistory.push(enemy.velocity.clone());

                        // Keep only recent history
                        if (pattern.movementHistory.length > 30) {
                            pattern.movementHistory.shift();
                        }

                        // Analyze enemy skill level
                        if (enemy.isPlayer) {
                            pattern.skill = 'human_player';
                            this.tacticalMode = 'hunter'; // More aggressive against players
                        }
                    }
                });

                // Adaptive tactical mode based on situation
                const healthPercent = (this.ship.health + this.ship.shield) / 150;
                const enemyCount = ships.filter(s => s !== this.ship && s.alive).length;

                if (healthPercent < 0.3) {
                    this.tacticalMode = 'defensive';
                } else if (enemyCount === 1) {
                    this.tacticalMode = 'aggressive';
                } else if (healthPercent > 0.8) {
                    this.tacticalMode = 'hunter';
                } else {
                    this.tacticalMode = 'adaptive';
                }
            }

            executeAdvancedManeuver() {
                const maneuvers = this.training.neuralWeights.movementPattern;

                // Select best maneuver based on situation
                if (!this.currentManeuver || this.maneuverProgress >= 1) {
                    const weights = maneuvers.map(m => m.effectiveness);
                    const totalWeight = weights.reduce((a, b) => a + b, 0);
                    let random = Math.random() * totalWeight;

                    for (let i = 0; i < maneuvers.length; i++) {
                        random -= weights[i];
                        if (random <= 0) {
                            this.currentManeuver = maneuvers[i].type;
                            this.maneuverProgress = 0;
                            break;
                        }
                    }
                }

                // Execute current maneuver
                this.maneuverProgress += 0.02;

                switch (this.currentManeuver) {
                    case 'spiral':
                        this.executeSpiralManeuver();
                        break;
                    case 'zigzag':
                        this.executeZigzagManeuver();
                        break;
                    case 'vertical_loop':
                        this.executeVerticalLoop();
                        break;
                    case 'barrel_roll':
                        this.executeBarrelRoll();
                        break;
                    case 'split_s':
                        this.executeSplitS();
                        break;
                    case 'immelmann':
                        this.executeImmelmann();
                        break;
                }
            }

            executeSpiralManeuver() {
                const angle = this.maneuverProgress * Math.PI * 4;
                const radius = 50 + this.maneuverProgress * 100;

                this.ship.velocity.x += Math.cos(angle) * 2;
                this.ship.velocity.z += Math.sin(angle) * 2;
                this.ship.velocity.y += Math.sin(angle * 2) * 1.5;

                this.ship.mesh.rotation.z = Math.sin(angle) * 0.5;
            }

            executeZigzagManeuver() {
                const zigzag = Math.sin(this.maneuverProgress * Math.PI * 8) * 5;
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(this.ship.mesh.quaternion);
                const right = new THREE.Vector3(1, 0, 0);
                right.applyQuaternion(this.ship.mesh.quaternion);

                this.ship.velocity.add(forward.multiplyScalar(3));
                this.ship.velocity.add(right.multiplyScalar(zigzag));
            }

            executeVerticalLoop() {
                const loopAngle = this.maneuverProgress * Math.PI * 2;
                this.ship.velocity.y += Math.cos(loopAngle) * 8;
                this.ship.mesh.rotation.x = -loopAngle;

                if (this.maneuverProgress > 0.5) {
                    this.ship.velocity.z += Math.sin(loopAngle) * 5;
                }
            }

            executeBarrelRoll() {
                this.ship.mesh.rotation.z += 0.2;
                const rollAngle = this.maneuverProgress * Math.PI * 2;
                this.ship.velocity.x += Math.sin(rollAngle) * 3;
                this.ship.velocity.y += Math.cos(rollAngle) * 2;
            }

            executeSplitS() {
                if (this.maneuverProgress < 0.5) {
                    this.ship.mesh.rotation.z = Math.PI * this.maneuverProgress * 2;
                    this.ship.velocity.y -= 10;
                } else {
                    this.ship.mesh.rotation.y += 0.1;
                    this.ship.velocity.y -= 5;
                }
            }

            executeImmelmann() {
                if (this.maneuverProgress < 0.5) {
                    this.ship.velocity.y += 10;
                    this.ship.mesh.rotation.x -= 0.1;
                } else {
                    this.ship.mesh.rotation.y += 0.2;
                    this.ship.velocity.y = 5;
                }
            }

            handleShooting() {
                if (!this.ship.target || !this.ship.target.alive) return;

                const now = Date.now();
                const distance = this.ship.mesh.position.distanceTo(this.ship.target.mesh.position);

                // Use trained attack patterns
                const attackData = this.training.neuralWeights.attackPattern.find(
                    p => distance <= p.range
                ) || this.training.neuralWeights.attackPattern[3];

                const projectileSpeed = CONFIG.LASER_SPEED;
                const timeToTarget = distance / projectileSpeed;

                // Advanced prediction using enemy patterns
                const enemyPattern = this.combatMemory.enemyPatterns.get(this.ship.target);
                let predictedPos;

                if (enemyPattern && enemyPattern.movementHistory.length > 10) {
                    // Use movement history for better prediction
                    const avgVelocity = enemyPattern.movementHistory
                        .slice(-10)
                        .reduce((acc, vel) => acc.add(vel), new THREE.Vector3())
                        .divideScalar(10);

                    predictedPos = this.ship.target.mesh.position.clone();
                    predictedPos.add(avgVelocity.multiplyScalar(timeToTarget * attackData.leadTime * 10));
                } else {
                    predictedPos = this.predictTargetPosition(this.ship.target, timeToTarget * attackData.leadTime);
                }

                const aimDirection = new THREE.Vector3().subVectors(predictedPos, this.ship.mesh.position).normalize();
                const currentDirection = new THREE.Vector3(0, 0, -1);
                currentDirection.applyQuaternion(this.ship.mesh.quaternion);

                const aimAccuracy = aimDirection.dot(currentDirection);

                const canShoot = now - this.ship.lastShot > this.skill.reactionTime;
                const goodShot = aimAccuracy > (0.98 * attackData.accuracy);
                const inRange = distance < attackData.range;

                this.ship.mesh.lookAt(predictedPos);

                if (canShoot && goodShot && inRange) {
                    // Multi-shot burst pattern
                    const burstCount = Math.floor(this.skill.accuracy * 3);
                    for (let i = 0; i < burstCount; i++) {
                        setTimeout(() => {
                            if (this.ship.alive && this.ship.target && this.ship.target.alive) {
                                // Slight spread for burst fire
                                const spread = (i - burstCount / 2) * 0.01;
                                this.ship.mesh.rotation.y += spread;
                                this.ship.fire();
                                this.ship.mesh.rotation.y -= spread;
                            }
                        }, i * 50);
                    }

                    // Record successful attack pattern
                    this.combatMemory.successfulManeuvers.push({
                        type: 'burst_fire',
                        distance: distance,
                        accuracy: aimAccuracy
                    });
                }
            }

            evadeThreats() {
                // Use trained dodge patterns
                const dodgePatterns = this.training.neuralWeights.dodgePattern;
                let bestDodge = null;
                let highestSuccess = 0;

                // Analyze all threats and pick best dodge
                lasers.forEach(laser => {
                    if (laser.owner !== this.ship) {
                        const distance = this.ship.mesh.position.distanceTo(laser.mesh.position);
                        const laserDir = laser.velocity.clone().normalize();
                        const toShip = new THREE.Vector3().subVectors(this.ship.mesh.position, laser.mesh.position);
                        const timeToImpact = toShip.length() / laser.velocity.length();

                        if (timeToImpact < 2 && timeToImpact > 0) {
                            // Select best dodge pattern
                            dodgePatterns.forEach(pattern => {
                                if (pattern.success > highestSuccess) {
                                    highestSuccess = pattern.success;
                                    bestDodge = pattern;
                                }
                            });
                        }
                    }
                });

                if (bestDodge && Date.now() - this.combatMemory.lastDodgeTime > 200) {
                    // Execute trained dodge maneuver
                    const dodgeAngle = bestDodge.angle * Math.PI / 180;
                    const dodgeVector = new THREE.Vector3(
                        Math.cos(dodgeAngle) * bestDodge.speed * 10,
                        Math.sin(dodgeAngle) * bestDodge.speed * 5,
                        Math.sin(dodgeAngle + Math.PI / 2) * bestDodge.speed * 10
                    );

                    this.ship.velocity.add(dodgeVector);
                    this.combatMemory.lastDodgeTime = Date.now();

                    // Execute evasive maneuver
                    this.currentManeuver = 'barrel_roll';
                    this.maneuverProgress = 0;
                }

                super.evadeThreats();
            }

            attackTarget() {
                if (!this.ship.target) return;

                // Execute combat maneuvers while attacking
                this.executeAdvancedManeuver();

                // Tactical positioning based on mode
                const distance = this.ship.mesh.position.distanceTo(this.ship.target.mesh.position);
                const optimalRange = this.tacticalMode === 'aggressive' ? 200 : 300;

                if (Math.abs(distance - optimalRange) > 50) {
                    const direction = new THREE.Vector3().subVectors(
                        this.ship.target.mesh.position,
                        this.ship.mesh.position
                    ).normalize();

                    if (distance > optimalRange) {
                        this.ship.velocity.add(direction.multiplyScalar(0.6));
                    } else {
                        this.ship.velocity.add(direction.multiplyScalar(-0.4));
                    }
                }

                // Advanced strafing with prediction
                const enemyPattern = this.combatMemory.enemyPatterns.get(this.ship.target);
                if (enemyPattern && enemyPattern.movementHistory.length > 5) {
                    const predictedMove = enemyPattern.movementHistory[enemyPattern.movementHistory.length - 1];
                    const perpendicular = new THREE.Vector3(-predictedMove.z, 0, predictedMove.x).normalize();
                    this.ship.velocity.add(perpendicular.multiplyScalar(3));
                }
            }
        }

        // Update Ship constructor to use Ultra Advanced AI
        class Ship {
            constructor(config, index) {
                this.config = config || {name: 'AI', color: 0xff0000, emissive: 0xff0000};
                this.name = this.config.name;
                this.health = CONFIG.SHIP_HP;
                this.shield = CONFIG.SHIELD_HP;
                this.alive = true;
                this.velocity = new THREE.Vector3();
                this.target = null;
                this.lastShot = 0;
                this.score = 0;
                this.kills = 0;
                this.isPlayer = false;

                // Use Ultra Advanced AI with 500 generations of training
                if (!this.isPlayer) {
                    this.ai = new UltraAdvancedAI(this);
                }

                this.createModel();

                // Position ships
                if (CONFIG.SHIPS === 2) {
                    if (index === 0) {
                        this.mesh.position.set(-300, 200, 0);
                        this.mesh.rotation.y = Math.PI / 2;
                    } else {
                        this.mesh.position.set(300, 200, 0);
                        this.mesh.rotation.y = -Math.PI / 2;
                    }
                } else {
                    const angle = (Math.PI * 2 * index) / CONFIG.SHIPS;
                    this.mesh.position.x = Math.cos(angle) * CONFIG.ARENA_SIZE * 0.9;
                    this.mesh.position.z = Math.sin(angle) * CONFIG.ARENA_SIZE * 0.9;
                    this.mesh.position.y = 150 + (index % 3) * 50;
                }
            }

            createModel() {
                const group = new THREE.Group();

                // Fighter jet body
                const bodyGeometry = new THREE.CylinderGeometry(4, 12, 80, 8);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: this.config.color,
                    emissive: this.config.emissive,
                    emissiveIntensity: 0.5
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                group.add(body);

                // Wings
                const wingGeometry = new THREE.BoxGeometry(120, 2, 32);
                const wingMaterial = new THREE.MeshPhongMaterial({
                    color: this.config.color,
                    emissive: this.config.emissive,
                    emissiveIntensity: 0.3
                });
                const wings = new THREE.Mesh(wingGeometry, wingMaterial);
                wings.position.x = -8;
                group.add(wings);

                // Cockpit
                const cockpitGeometry = new THREE.SphereGeometry(8, 8, 6);
                const cockpitMaterial = new THREE.MeshPhongMaterial({
                    color: 0x333333,
                    transparent: true,
                    opacity: 0.8
                });
                const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
                cockpit.position.x = 28;
                group.add(cockpit);

                // Tail
                const tailGeometry = new THREE.BoxGeometry(2, 32, 20);
                const tailMaterial = new THREE.MeshPhongMaterial({
                    color: this.config.color,
                    emissive: this.config.emissive,
                    emissiveIntensity: 0.3
                });
                const tail = new THREE.Mesh(tailGeometry, tailMaterial);
                tail.position.x = -32;
                tail.position.y = 12;
                group.add(tail);

                this.mesh = group;
                scene.add(this.mesh);
            }

            update() {
                if (!this.alive) return;

                // AI movement with advanced system
                if (!this.isPlayer && this.ai) {
                    this.ai.update();
                }

                // Apply velocity
                const maxSpeed = this.isPlayer ? CONFIG.SHIP_SPEED : CONFIG.SHIP_SPEED * 1.2; // AI is slightly faster
                if (this.velocity.length() > maxSpeed) {
                    this.velocity.normalize().multiplyScalar(maxSpeed);
                }

                this.mesh.position.add(this.velocity);
                this.velocity.multiplyScalar(0.95);

                // Boundaries
                const boundary = CONFIG.ARENA_SIZE;
                ['x', 'z'].forEach(axis => {
                    if (Math.abs(this.mesh.position[axis]) > boundary) {
                        this.mesh.position[axis] = Math.sign(this.mesh.position[axis]) * boundary;
                        this.velocity[axis] *= -0.8;
                    }
                });

                // Height limits
                if (this.mesh.position.y < CONFIG.MIN_HEIGHT) {
                    this.mesh.position.y = CONFIG.MIN_HEIGHT;
                    this.velocity.y = Math.abs(this.velocity.y) * 0.8;
                }
                if (this.mesh.position.y > CONFIG.MAX_HEIGHT) {
                    this.mesh.position.y = CONFIG.MAX_HEIGHT;
                    this.velocity.y = -Math.abs(this.velocity.y) * 0.8;
                }
            }
    }

        fire()
        {
            this.lastShot = Date.now();

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(this.mesh.quaternion);

            const laser = new Laser(this.mesh.position, direction, this.config.color, this);
            lasers.push(laser);

            playSound('shoot');
        }

        takeDamage(amount)
        {
            if (this.shield > 0) {
                this.shield -= amount;
                if (this.shield < 0) {
                    this.health += this.shield;
                    this.shield = 0;
                }
            } else {
                this.health -= amount;
            }

            if (this.health <= 0) {
                this.alive = false;
                this.destroy();
            }

            if (this.isPlayer) {
                const healthBar = document.getElementById('playerHealthBar');
                const shieldBar = document.getElementById('playerShieldBar');
                if (healthBar) healthBar.style.width = this.health + '%';
                if (shieldBar) shieldBar.style.width = this.shield + '%';
            }
        }

        destroy()
        {
            const explosionGeometry = new THREE.SphereGeometry(80, 16, 16);
            const explosionMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 1
            });
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosion.position.copy(this.mesh.position);
            scene.add(explosion);

            const animateExplosion = () => {
                explosion.scale.multiplyScalar(1.1);
                explosionMaterial.opacity *= 0.9;
                if (explosionMaterial.opacity > 0.01) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    scene.remove(explosion);
                }
            };
            animateExplosion();

            scene.remove(this.mesh);
            playSound('explosion');
        }
    })
    // Player Ship class
    class PlayerShip extends Ship {
        constructor() {
            const playerConfig = {
                name: 'PLAYER',
                color: 0x00ff00,
                emissive: 0x00ff00
            };
            super(playerConfig, -1);

            this.mesh.position.set(0, 150, 300);
            this.isPlayer = true;
            this.keys = {
                up: false,
                down: false,
                left: false,
                right: false,
                fire: false,
                boost: false,
                special: false,
                switchWeapon: false
            };

            this.weaponType = 'PLASMA';
            this.specialWeaponReady = true;
            this.specialCooldown = 0;

            // Weapon system
            this.weapons = ['PLASMA', 'LASER', 'ROCKETS'];
            this.currentWeaponIndex = 0;
            this.weaponStats = {
                'PLASMA': { damage: 20, fireRate: 200, speed: 25, color: 0x00ff00 },
                'LASER': { damage: 10, fireRate: 100, speed: 40, color: 0x00ffff },
                'ROCKETS': { damage: 50, fireRate: 800, speed: 15, color: 0xff6600 }
            };
        }

        update() {
            if (!this.alive) return;

            // Movement
            if (this.keys.up) {
                this.mesh.rotation.x = Math.max(this.mesh.rotation.x - 0.02, -Math.PI / 4);
            }
            if (this.keys.down) {
                this.mesh.rotation.x = Math.min(this.mesh.rotation.x + 0.02, Math.PI / 4);
            }
            if (this.keys.left) {
                this.mesh.rotation.z = Math.min(this.mesh.rotation.z + 0.03, Math.PI / 3);
                this.mesh.rotation.y += 0.025;
            }
            if (this.keys.right) {
                this.mesh.rotation.z = Math.max(this.mesh.rotation.z - 0.03, -Math.PI / 3);
                this.mesh.rotation.y -= 0.025;
            }

            if (!this.keys.left && !this.keys.right) {
                this.mesh.rotation.z *= 0.95;
            }

            const speed = this.keys.boost ? CONFIG.BOOST_SPEED : CONFIG.SHIP_SPEED;
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(this.mesh.quaternion);
            this.velocity = direction.multiplyScalar(speed);

            this.mesh.position.add(this.velocity.clone().multiplyScalar(0.1));

            // Boundaries
            const boundary = CONFIG.ARENA_SIZE;
            ['x', 'z'].forEach(axis => {
                if (Math.abs(this.mesh.position[axis]) > boundary) {
                    this.mesh.position[axis] = Math.sign(this.mesh.position[axis]) * boundary;
                    this.velocity[axis] *= -0.8;
                }
            });

            // Height limits
            if (this.mesh.position.y < CONFIG.MIN_HEIGHT) {
                this.mesh.position.y = CONFIG.MIN_HEIGHT;
            }
            if (this.mesh.position.y > CONFIG.MAX_HEIGHT) {
                this.mesh.position.y = CONFIG.MAX_HEIGHT;
            }

            // Fire
            if (this.keys.fire && Date.now() - this.lastShot > this.weaponStats[this.weaponType].fireRate) {
                this.fire();
            }

            // Special weapon
            if (this.keys.special && this.specialWeaponReady) {
                this.fireNuclearMissile();
            }

            // Switch weapon
            if (this.keys.switchWeapon && !this.weaponSwitchCooldown) {
                this.switchWeapon();
                this.weaponSwitchCooldown = true;
                setTimeout(() => { this.weaponSwitchCooldown = false; }, 300);
            }

            // Update special cooldown
            if (!this.specialWeaponReady) {
                this.specialCooldown--;
                if (this.specialCooldown <= 0) {
                    this.specialWeaponReady = true;
                    document.getElementById('specialReady').textContent = 'READY';
                    document.getElementById('specialReady').classList.add('special-ready');
                } else {
                    const seconds = Math.ceil(this.specialCooldown / 60);
                    document.getElementById('specialReady').textContent = `${seconds}s`;
                    document.getElementById('specialReady').classList.remove('special-ready');
                }
            }

            // Update score
            this.score = this.kills * 100;
            document.getElementById('playerScore').textContent = this.score;
        }

        switchWeapon() {
            this.currentWeaponIndex = (this.currentWeaponIndex + 1) % this.weapons.length;
            this.weaponType = this.weapons[this.currentWeaponIndex];

            document.getElementById('playerWeapon').textContent = this.weaponType;
            showNotification(`Weapon: ${this.weaponType}`);
            playSound('powerup');
        }

        fire() {
            this.lastShot = Date.now();

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(this.mesh.quaternion);

            const weaponData = this.weaponStats[this.weaponType];

            if (this.weaponType === 'ROCKETS') {
                const rocket = new Rocket(this.mesh.position.clone(), direction, this);
                lasers.push(rocket);
            } else {
                const laser = new Laser(
                    this.mesh.position,
                    direction,
                    weaponData.color,
                    this,
                    weaponData.damage,
                    weaponData.speed
                );
                lasers.push(laser);
            }

            playSound('shoot');
        }

        fireNuclearMissile() {
            this.specialWeaponReady = false;
            this.specialCooldown = 600; // 10 seconds

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(this.mesh.quaternion);

            const missile = new NuclearMissile(this.mesh.position.clone(), direction, this);
            missiles.push(missile);

            showNotification('☢️ NUCLEAR MISSILE LAUNCHED!');
            playSound('powerup');
        }

        destroy() {
            super.destroy();

            document.getElementById('winnerName').textContent = 'GAME OVER';
            document.getElementById('winnerName').style.color = '#ff0000';
            document.getElementById('winnerStats').innerHTML = `Your Score: ${this.score}<br>Eliminations: ${this.kills}`;
            document.getElementById('restartText').style.display = 'none';
            document.getElementById('menuButtons').style.display = 'block';
            document.getElementById('winnerOverlay').style.display = 'flex';
        }
    }

    // Laser class
    class Laser {
        constructor(position, direction, color, owner, damage = CONFIG.DAMAGE, speed = CONFIG.LASER_SPEED) {
            this.owner = owner;
            this.damage = damage;
            this.velocity = direction.multiplyScalar(speed);

            const geometry = new THREE.CylinderGeometry(0.8, 0.8, 40);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                emissive: color
            });
            this.mesh = new THREE.Mesh(geometry, material);
            this.mesh.position.copy(position);

            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
            this.mesh.quaternion.copy(quaternion);

            scene.add(this.mesh);
        }

        update() {
            this.mesh.position.add(this.velocity);

            if (this.mesh.position.length() > CONFIG.ARENA_SIZE * 1.5) {
                this.destroy();
                return false;
            }

            for (let ship of ships) {
                if (ship !== this.owner && ship.alive) {
                    const distance = this.mesh.position.distanceTo(ship.mesh.position);
                    if (distance < 40) {
                        ship.takeDamage(this.damage);
                        if (!ship.alive && this.owner) {
                            this.owner.kills++;
                            this.owner.score += 100;
                        }
                        this.destroy();
                        return false;
                    }
                }
            }

            return true;
        }

        destroy() {
            scene.remove(this.mesh);
        }
    }

    // Rocket class
    class Rocket {
        constructor(position, direction, owner) {
            this.owner = owner;
            this.damage = 50;
            this.velocity = direction.multiplyScalar(15);

            const group = new THREE.Group();

            const bodyGeometry = new THREE.CylinderGeometry(2, 3, 20, 6);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0xff6600,
                emissive: 0xff3300,
                emissiveIntensity: 0.5
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.z = Math.PI / 2;
            group.add(body);

            const tipGeometry = new THREE.ConeGeometry(3, 8, 6);
            const tipMaterial = new THREE.MeshPhongMaterial({
                color: 0xffaa00,
                emissive: 0xff6600,
                emissiveIntensity: 0.7
            });
            const tip = new THREE.Mesh(tipGeometry, tipMaterial);
            tip.position.x = 14;
            tip.rotation.z = -Math.PI / 2;
            group.add(tip);

            this.mesh = group;
            this.mesh.position.copy(position);

            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), direction);
            this.mesh.quaternion.copy(quaternion);

            scene.add(this.mesh);
        }

        update() {
            this.mesh.position.add(this.velocity);

            if (this.mesh.position.length() > CONFIG.ARENA_SIZE * 1.5) {
                this.destroy();
                return false;
            }

            for (let ship of ships) {
                if (ship !== this.owner && ship.alive) {
                    const distance = this.mesh.position.distanceTo(ship.mesh.position);
                    if (distance < 40) {
                        ship.takeDamage(this.damage);
                        if (!ship.alive && this.owner) {
                            this.owner.kills++;
                            this.owner.score += 100;
                        }
                        this.explode();
                        return false;
                    }
                }
            }

            return true;
        }

        explode() {
            const explosionGeometry = new THREE.SphereGeometry(30, 8, 8);
            const explosionMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 1
            });
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosion.position.copy(this.mesh.position);
            scene.add(explosion);

            const animateExplosion = () => {
                explosion.scale.multiplyScalar(1.15);
                explosionMaterial.opacity *= 0.85;
                if (explosionMaterial.opacity > 0.01) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    scene.remove(explosion);
                }
            };
            animateExplosion();

            playSound('explosion');
            this.destroy();
        }

        destroy() {
            scene.remove(this.mesh);
        }
    }

    // Nuclear Missile class
    class NuclearMissile {
        constructor(position, direction, owner) {
            this.owner = owner;
            this.velocity = direction.normalize().multiplyScalar(CONFIG.LASER_SPEED * 0.6);
            this.target = null;
            this.lifetime = 0;
            this.maxLifetime = 300;

            const group = new THREE.Group();

            const bodyGeometry = new THREE.CylinderGeometry(3, 5, 60, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0x666666,
                emissive: 0xff0000,
                emissiveIntensity: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.z = Math.PI / 2;
            group.add(body);

            const warheadGeometry = new THREE.ConeGeometry(5, 15, 8);
            const warheadMaterial = new THREE.MeshPhongMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.8
            });
            const warhead = new THREE.Mesh(warheadGeometry, warheadMaterial);
            warhead.position.x = 37.5;
            warhead.rotation.z = -Math.PI / 2;
            group.add(warhead);

            this.mesh = group;
            this.mesh.position.copy(position);

            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), direction);
            this.mesh.quaternion.copy(quaternion);

            this.warningLight = new THREE.PointLight(0xff0000, 5, 100);
            this.warningLight.position.copy(position);
            scene.add(this.warningLight);

            scene.add(this.mesh);

            this.findTarget();
        }

        findTarget() {
            let nearestDist = Infinity;
            let nearestShip = null;

            ships.forEach(ship => {
                if (ship !== this.owner && ship.alive) {
                    const dist = this.mesh.position.distanceTo(ship.mesh.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestShip = ship;
                    }
                }
            });

            this.target = nearestShip;
        }

        update() {
            this.lifetime++;

            if (this.lifetime > this.maxLifetime) {
                this.explode();
                return false;
            }

            if (!this.target || !this.target.alive) {
                this.findTarget();
            }

            if (this.target) {
                const toTarget = new THREE.Vector3();
                toTarget.subVectors(this.target.mesh.position, this.mesh.position);
                toTarget.normalize();

                const turnSpeed = 0.02;
                this.velocity.lerp(toTarget.multiplyScalar(this.velocity.length()), turnSpeed);
            }

            this.mesh.position.add(this.velocity);

            const lookAtPos = this.mesh.position.clone().add(this.velocity);
            this.mesh.lookAt(lookAtPos);
            this.mesh.rotateZ(Math.PI / 2);

            this.warningLight.position.copy(this.mesh.position);
            this.warningLight.intensity = 5 + Math.sin(Date.now() * 0.01) * 2;

            if (this.target) {
                const distance = this.mesh.position.distanceTo(this.target.mesh.position);
                if (distance < 50) {
                    this.explode();
                    return false;
                }
            }

            if (this.mesh.position.y < 10) {
                this.explode();
                return false;
            }

            return true;
        }

        explode() {
            const flashGeometry = new THREE.SphereGeometry(100, 32, 32);
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 1
            });
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            flash.position.copy(this.mesh.position);
            scene.add(flash);

            const shockwaveGeometry = new THREE.RingGeometry(1, 10, 32);
            const shockwaveMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
            shockwave.position.copy(this.mesh.position);
            shockwave.rotation.x = -Math.PI / 2;
            scene.add(shockwave);

            const blastRadius = 400;
            ships.forEach(ship => {
                if (ship.alive) {
                    const distance = this.mesh.position.distanceTo(ship.mesh.position);
                    if (distance < blastRadius) {
                        const damage = Math.max(0, (1 - distance / blastRadius) * 200);
                        ship.takeDamage(damage);
                    }
                }
            });

            let frame = 0;
            const animateExplosion = () => {
                frame++;
                flash.scale.multiplyScalar(1.1);
                flashMaterial.opacity *= 0.9;
                shockwave.scale.multiplyScalar(1.15);
                shockwave.material.opacity *= 0.95;

                if (frame < 100) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    scene.remove(flash);
                    scene.remove(shockwave);
                }
            };
            animateExplosion();

            playSound('explosion');
            this.destroy();
        }

        destroy() {
            scene.remove(this.mesh);
            scene.remove(this.warningLight);
        }
    }

    // Game functions
    function startBattle() {
        timer = CONFIG.BATTLE_TIME;
        ships = [];
        lasers = [];
        missiles = [];
        gameState = 'battle';
        playerShip = null;

        if (gameMode === 'player' || gameMode === 'mixed') {
            playerShip = new PlayerShip();
            ships.push(playerShip);
            setupPlayerControls();
        }

        const aiCount = gameMode === 'player' ? 1 : (gameMode === 'mixed' ? 1 : 2);
        for (let i = 0; i < aiCount; i++) {
            const config = {
                name: `AI-${i + 1}`,
                color: Math.random() * 0xffffff,
                emissive: Math.random() * 0xffffff
            };
            const ship = new Ship(config, i);
            ships.push(ship);
        }

        gameLoop();
    }

    function gameLoop() {
        if (gameState !== 'battle') return;

        timer--;
        updateHUD();

        const alive = ships.filter(s => s.alive);

        if (gameMode === 'player' || gameMode === 'mixed') {
            if (playerShip && !playerShip.alive) {
                gameState = 'ended';
                return;
            }
        }

        if (alive.length <= 1 || timer <= 0) {
            endBattle();
            return;
        }

        setTimeout(gameLoop, 1000);
    }

    function endBattle() {
        gameState = 'ended';

        const alive = ships.filter(s => s.alive);
        const winner = alive.length > 0 ? alive[0] : ships[0];

        if (gameMode === 'ai' || (winner && !winner.isPlayer)) {
            document.getElementById('winnerName').textContent = winner.name;
            document.getElementById('winnerName').style.color = '#' + winner.config.color.toString(16).padStart(6, '0');
            document.getElementById('winnerStats').innerHTML = `Score: ${winner.score}<br>Eliminations: ${winner.kills}`;
            document.getElementById('restartText').style.display = 'block';
            document.getElementById('menuButtons').style.display = 'none';
            document.getElementById('winnerOverlay').style.display = 'flex';

            if (gameMode === 'ai') {
                let countdown = 5;
                const countInterval = setInterval(() => {
                    countdown--;
                    document.getElementById('countdown').textContent = countdown;
                    if (countdown <= 0) {
                        clearInterval(countInterval);
                        document.getElementById('winnerOverlay').style.display = 'none';
                        cleanupBattle();
                        startBattle();
                    }
                }, 1000);
            }
        }
    }

    function cleanupBattle() {
        ships.forEach(ship => {
            if (ship.mesh) scene.remove(ship.mesh);
        });
        lasers.forEach(laser => {
            scene.remove(laser.mesh);
        });
        missiles.forEach(missile => {
            missile.destroy();
        });
        ships = [];
        lasers = [];
        missiles = [];
    }

    function updateHUD() {
        const alive = ships.filter(s => s.alive);
        document.getElementById('aliveCount').textContent = alive.length;

        const minutes = Math.floor(timer / 60);
        const seconds = timer % 60;
        document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    // Player controls
    function setupPlayerControls() {
        document.addEventListener('keydown', (e) => {
            if (!playerShip || !playerShip.alive) return;

            switch(e.key) {
                case 'ArrowUp': playerShip.keys.up = true; e.preventDefault(); break;
                case 'ArrowDown': playerShip.keys.down = true; e.preventDefault(); break;
                case 'ArrowLeft': playerShip.keys.left = true; e.preventDefault(); break;
                case 'ArrowRight': playerShip.keys.right = true; e.preventDefault(); break;
                case ' ': playerShip.keys.fire = true; e.preventDefault(); break;
                case 'Shift': playerShip.keys.boost = true; e.preventDefault(); break;
                case 'e':
                case 'E': playerShip.keys.special = true; e.preventDefault(); break;
                case 'q':
                case 'Q':
                    if (!playerShip.weaponSwitchCooldown) {
                        playerShip.keys.switchWeapon = true;
                        e.preventDefault();
                    }
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (!playerShip || !playerShip.alive) return;

            switch(e.key) {
                case 'ArrowUp': playerShip.keys.up = false; break;
                case 'ArrowDown': playerShip.keys.down = false; break;
                case 'ArrowLeft': playerShip.keys.left = false; break;
                case 'ArrowRight': playerShip.keys.right = false; break;
                case ' ': playerShip.keys.fire = false; break;
                case 'Shift': playerShip.keys.boost = false; break;
                case 'e':
                case 'E': playerShip.keys.special = false; break;
                case 'q':
                case 'Q': playerShip.keys.switchWeapon = false; break;
            }
        });
    }

    // Animation loop
    function animate() {
        requestAnimationFrame(animate);

        const time = Date.now() * 0.0001;
        if (gameMode === 'player' && playerShip && playerShip.alive) {
            const offset = new THREE.Vector3(0, 30, 80);
            offset.applyQuaternion(playerShip.mesh.quaternion);
            camera.position.copy(playerShip.mesh.position).add(offset);

            const lookAt = new THREE.Vector3(0, 0, -100);
            lookAt.applyQuaternion(playerShip.mesh.quaternion);
            lookAt.add(playerShip.mesh.position);
            camera.lookAt(lookAt);
        } else {
            camera.position.x = Math.cos(time) * 600;
            camera.position.z = Math.sin(time) * 600;
            camera.position.y = 300 + Math.sin(time * 2) * 100;
            camera.lookAt(0, 100, 0);
        }

        if (gameState === 'battle') {
            ships.forEach(ship => ship.update());
            lasers = lasers.filter(laser => laser.update());
            missiles = missiles.filter(missile => missile.update());
        }

        renderer.render(scene, camera);
    }

    // Handle resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start game
    init();
</script>
</body>
</html>