<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky & Sea Battle 3D - Epic Naval Air Combat</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Orbitron', monospace;
            background: #000;
            cursor: crosshair;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Main Menu */
        .main-menu {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
            backdrop-filter: blur(20px);
        }

        .menu-content {
            text-align: center;
            animation: menuFadeIn 0.5s ease-out;
        }

        @keyframes menuFadeIn {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .game-title {
            font-size: 72px;
            font-weight: 900;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
        }

        .menu-subtitle {
            font-size: 24px;
            color: #888;
            margin-bottom: 50px;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 40px;
        }

        .menu-btn {
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 20px 60px;
            font-size: 24px;
            font-family: 'Orbitron', monospace;
            cursor: pointer;
            border-radius: 15px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .menu-btn:hover {
            background: linear-gradient(145deg, #16213e, #1a1a2e);
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 255, 255, 0.5);
        }

        .btn-desc {
            display: block;
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }

        .controls-info {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            border-radius: 10px;
            padding: 20px;
            text-align: left;
            max-width: 400px;
            margin: 0 auto;
        }

        .controls-info h3 {
            color: #00ffff;
            margin-bottom: 15px;
            text-align: center;
        }

        .control-item {
            color: #aaa;
            margin: 8px 0;
            font-size: 14px;
        }

        /* HUD */
        .hud {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 20px;
            padding: 15px 30px;
            backdrop-filter: blur(10px);
            z-index: 100;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        .hud-content {
            display: flex;
            gap: 40px;
            align-items: center;
        }

        .stat-item {
            text-align: center;
            color: #fff;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
        }

        /* Player HUD */
        .player-hud {
            position: fixed;
            bottom: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff00;
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            z-index: 100;
            min-width: 300px;
        }

        .player-stats {
            margin-bottom: 20px;
        }

        .health-bar, .shield-bar {
            margin-bottom: 15px;
        }

        .bar-label {
            color: #aaa;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .bar-container {
            width: 250px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            border-radius: 10px;
            overflow: hidden;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .health-fill {
            background: linear-gradient(90deg, #00ff00, #00cc00);
        }

        .shield-fill {
            background: linear-gradient(90deg, #00ffff, #0099cc);
        }

        .weapon-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }

        .weapon-name {
            color: #00ff00;
            font-size: 18px;
            font-weight: bold;
        }

        .special-weapon {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff0000;
            border-radius: 10px;
        }

        .special-status {
            color: #ff0000;
            font-size: 14px;
            text-align: center;
        }

        .special-ready {
            color: #00ff00;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }

        .player-score {
            text-align: center;
            border-top: 1px solid #444;
            padding-top: 15px;
        }

        .score-label {
            color: #aaa;
            font-size: 12px;
        }

        .score-value {
            font-size: 36px;
            font-weight: bold;
            background: linear-gradient(45deg, #00ff00, #ffff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Winner */
        .winner-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
            backdrop-filter: blur(10px);
        }

        .winner-content {
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            border: 3px solid #ffd700;
            border-radius: 30px;
            padding: 50px;
            text-align: center;
            box-shadow:
                    0 0 100px rgba(255, 215, 0, 0.5),
                    inset 0 0 50px rgba(255, 215, 0, 0.1);
        }

        .winner-title {
            font-size: 56px;
            color: #ffd700;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
        }

        .menu-btn-small {
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 10px 30px;
            margin: 0 10px;
            font-size: 16px;
            font-family: 'Orbitron', monospace;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .menu-btn-small:hover {
            background: linear-gradient(145deg, #16213e, #1a1a2e);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 255, 0.5);
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 24px;
            z-index: 300;
        }

        /* Notifications */
        .notification {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px 30px;
            color: #00ffff;
            font-size: 18px;
            z-index: 500;
            animation: notifSlide 0.3s ease-out;
        }

        @keyframes notifSlide {
            from {
                transform: translateX(-50%) translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>

<div class="loading" id="loading">Initializing 3D System...</div>

<!-- Menu Principal -->
<div class="main-menu" id="mainMenu">
    <div class="menu-content">
        <h1 class="game-title">SKY & SEA BATTLE</h1>
        <div class="menu-subtitle">Epic Naval Air Combat</div>

        <div class="menu-buttons">
            <button class="menu-btn" id="btnPlayerMode">
                🎮 PLAYER MODE
                <span class="btn-desc">Pilot your own fighter jet</span>
            </button>

            <button class="menu-btn" id="btnMixedMode">
                🎮+🤖 PLAYER + AI
                <span class="btn-desc">Battle against AI opponents</span>
            </button>

            <button class="menu-btn" id="btnAIMode">
                🤖 AI ONLY MODE
                <span class="btn-desc">Watch AI battles evolve</span>
            </button>
        </div>

        <div class="controls-info">
            <h3>Player Controls:</h3>
            <div class="control-item">↑↓ - Pitch (up/down)</div>
            <div class="control-item">←→ - Roll & Turn</div>
            <div class="control-item">SPACE - Fire weapon</div>
            <div class="control-item">SHIFT - Boost</div>
            <div class="control-item">E - Nuclear Missile ☢️</div>
            <div class="control-item">Q - Switch weapon</div>
        </div>
    </div>
</div>

<!-- Player HUD -->
<div class="player-hud" id="playerHUD" style="display: none;">
    <div class="player-stats">
        <div class="health-bar">
            <div class="bar-label">HEALTH</div>
            <div class="bar-container">
                <div class="bar-fill health-fill" id="playerHealthBar"></div>
            </div>
        </div>
        <div class="shield-bar">
            <div class="bar-label">SHIELD</div>
            <div class="bar-container">
                <div class="bar-fill shield-fill" id="playerShieldBar"></div>
            </div>
        </div>
        <div class="weapon-info">
            <div class="weapon-name" id="playerWeapon">PLASMA</div>
            <div class="ammo-count" id="playerAmmo">100/100</div>
        </div>
        <div class="special-weapon">
            <div class="special-status" id="specialStatus">
                <span style="font-size: 20px;">☢️</span> NUCLEAR MISSILE
                <span class="special-ready" id="specialReady">READY</span>
            </div>
        </div>
    </div>
    <div class="player-score">
        <div class="score-label">SCORE</div>
        <div class="score-value" id="playerScore">0</div>
    </div>
</div>

<!-- HUD -->
<div class="hud" id="hud" style="display: none;">
    <div class="hud-content">
        <div class="stat-item">
            <div class="stat-value" id="aliveCount">0</div>
            <div class="stat-label">Survivors</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="timer">0:00</div>
            <div class="stat-label">Time</div>
        </div>
    </div>
</div>

<!-- Winner Overlay -->
<div class="winner-overlay" id="winnerOverlay">
    <div class="winner-content">
        <div class="winner-title">🏆 VICTORY 🏆</div>
        <div id="winnerName" style="font-size: 42px; margin-bottom: 20px;"></div>
        <div id="winnerStats" style="font-size: 20px; color: #00ffff; margin-bottom: 20px;"></div>
        <div style="color: #888;">
            <span id="restartText">New battle in <span id="countdown">5</span>...</span>
            <div id="menuButtons" style="display: none; margin-top: 20px;">
                <button class="menu-btn-small" id="btnRestart">Play Again</button>
                <button class="menu-btn-small" id="btnMenu">Main Menu</button>
            </div>
        </div>
    </div>
</div>

<!-- Scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Configuration
    const CONFIG = {
        SHIPS: 2,
        ARENA_SIZE: 500,
        SHIP_SPEED: 8,
        BOOST_SPEED: 15,
        LASER_SPEED: 25,
        SHIP_HP: 100,
        SHIELD_HP: 50,
        DAMAGE: 20,
        MIN_HEIGHT: 20,
        MAX_HEIGHT: 300,
        BATTLE_TIME: 180,
        BOOST_DRAIN: 1,
        BOOST_RECHARGE: 0.5
    };

    // Global variables
    let scene, camera, renderer;
    let ships = [];
    let lasers = [];
    let missiles = [];
    let powerups = [];
    let birds = [];
    let killFeed = [];
    let gameState = 'menu';
    let gameMode = 'ai';
    let playerShip = null;
    let timer = CONFIG.BATTLE_TIME;
    let isPaused = false;
    let soundEnabled = true;
    let showPerf = false;
    let cameraMode = 0;
    let cameraModes = ['follow', 'orbit', 'free'];
    let lastTime = 0;
    let fps = 0;
    let combo = 0;
    let comboTimer = null;

    // Audio Context for sound effects
    let audioContext;
    let sounds = {};

    // Menu functions
    function startPlayerMode() {
        gameMode = 'player';
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('playerHUD').style.display = 'block';
        document.getElementById('hud').style.display = 'block';
        startBattle();
    }

    function startMixedMode() {
        gameMode = 'mixed';
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('playerHUD').style.display = 'block';
        document.getElementById('hud').style.display = 'block';
        startBattle();
    }

    function startAIMode() {
        gameMode = 'ai';
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('hud').style.display = 'block';
        startBattle();
    }

    function returnToMenu() {
        gameState = 'menu';
        cleanupBattle();
        document.getElementById('mainMenu').style.display = 'flex';
        document.getElementById('playerHUD').style.display = 'none';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('winnerOverlay').style.display = 'none';
    }

    function restartBattle() {
        document.getElementById('winnerOverlay').style.display = 'none';
        cleanupBattle();
        startBattle();
    }

    // Initialize Audio
    function initAudio() {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Create basic sound effects
            sounds.shoot = createSound(200, 0.1, 'square');
            sounds.explosion = createSound(50, 0.3, 'sawtooth');
            sounds.hit = createSound(150, 0.1, 'triangle');
            sounds.powerup = createSound(400, 0.2, 'sine');
            sounds.boost = createSound(100, 0.2, 'sawtooth');
        } catch (e) {
            console.log('Audio not supported');
            soundEnabled = false;
        }
    }

    // Create sound effect
    function createSound(frequency, duration, type) {
        return () => {
            if (!soundEnabled || !audioContext) return;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = type;

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        };
    }

    // Play sound
    function playSound(soundName) {
        if (sounds[soundName]) {
            sounds[soundName]();
        }
    }

    // Initialize Three.js
    function init() {
        // Show loading screen
        updateLoadingProgress(10, 'Loading 3D Engine...');

        // Scene setup
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xB0E0E6, 100, 2000);

        // Camera setup - Further back for bigger ships
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.set(0, 300, 600);
        camera.lookAt(0, 100, 0);

        // Renderer setup
        renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;

        updateLoadingProgress(30, 'Creating Environment...');

        // Environment
        createEnvironment();

        updateLoadingProgress(60, 'Setting up Lighting...');

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404080, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.5);
        sunLight.position.set(500, 800, 300);
        sunLight.castShadow = true;
        scene.add(sunLight);

        updateLoadingProgress(80, 'Initializing Audio...');

        // Initialize audio
        initAudio();

        updateLoadingProgress(100, 'Ready!');

        // Hide loading and show menu
        setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
        }, 500);

        // Setup button event listeners
        document.getElementById('btnPlayerMode').addEventListener('click', startPlayerMode);
        document.getElementById('btnMixedMode').addEventListener('click', startMixedMode);
        document.getElementById('btnAIMode').addEventListener('click', startAIMode);
        document.getElementById('btnRestart').addEventListener('click', restartBattle);
        document.getElementById('btnMenu').addEventListener('click', returnToMenu);

        // Start animation
        animate();
    }

    // Update loading progress
    function updateLoadingProgress(percent, text) {
        const loading = document.getElementById('loading');
        if (loading) loading.textContent = text;
    }

    // Show notification
    function showNotification(text) {
        const notif = document.createElement('div');
        notif.className = 'notification';
        notif.textContent = text;
        document.body.appendChild(notif);

        setTimeout(() => {
            notif.style.opacity = '0';
            setTimeout(() => notif.remove(), 500);
        }, 2000);
    }

    // Create environment
    function createEnvironment() {
        // Ocean - smaller area
        const oceanGeometry = new THREE.PlaneGeometry(1500, 1500, 128, 128);
        const oceanMaterial = new THREE.MeshPhongMaterial({
            color: 0x006994,
            transparent: true,
            opacity: 0.8,
            shininess: 100
        });
        const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
        ocean.rotation.x = -Math.PI / 2;
        ocean.position.z = -750;
        ocean.receiveShadow = true;
        scene.add(ocean);

        // Land/Ground
        const groundGeometry = new THREE.PlaneGeometry(3000, 1500, 10, 10);
        const groundMaterial = new THREE.MeshPhongMaterial({
            color: 0x3a5f3a,
            roughness: 0.8,
            metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.z = 750;
        ground.receiveShadow = true;
        scene.add(ground);

        // Sky
        const skyGeometry = new THREE.SphereGeometry(2000, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({
            color: 0x87CEEB,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // Simple city buildings
        for (let i = 0; i < 30; i++) {
            const buildingGeometry = new THREE.BoxGeometry(
                40 + Math.random() * 60,
                80 + Math.random() * 200,
                40 + Math.random() * 60
            );
            const buildingMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color(Math.random() * 0.3 + 0.3, Math.random() * 0.3 + 0.3, Math.random() * 0.3 + 0.3)
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.x = (Math.random() - 0.5) * 1000;
            building.position.y = building.geometry.parameters.height / 2;
            building.position.z = 200 + Math.random() * 600;
            building.castShadow = true;
            building.receiveShadow = true;
            scene.add(building);
        }

        // Clouds
        for (let i = 0; i < 20; i++) {
            const cloudGeometry = new THREE.SphereGeometry(30 + Math.random() * 50, 8, 6);
            const cloudMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.7
            });
            const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
            cloud.position.set(
                (Math.random() - 0.5) * 2000,
                350 + Math.random() * 200,
                (Math.random() - 0.5) * 2000
            );
            scene.add(cloud);
        }
    }

    // Nuclear Missile class
    class NuclearMissile {
        constructor(position, direction, owner) {
            this.owner = owner;
            this.velocity = direction.clone().normalize().multiplyScalar(CONFIG.LASER_SPEED * 0.6);
            this.target = null;
            this.lifetime = 0;
            this.maxLifetime = 300; // 5 seconds at 60fps

            // Create missile model
            const group = new THREE.Group();

            // Missile body
            const bodyGeometry = new THREE.CylinderGeometry(3, 5, 60, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0x666666,
                emissive: 0xff0000,
                emissiveIntensity: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.z = Math.PI / 2;
            group.add(body);

            // Warhead
            const warheadGeometry = new THREE.ConeGeometry(5, 15, 8);
            const warheadMaterial = new THREE.MeshPhongMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.8
            });
            const warhead = new THREE.Mesh(warheadGeometry, warheadMaterial);
            warhead.position.x = 37.5;
            warhead.rotation.z = -Math.PI / 2;
            group.add(warhead);

            // Fins
            const finGeometry = new THREE.BoxGeometry(2, 15, 8);
            const finMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            for (let i = 0; i < 4; i++) {
                const fin = new THREE.Mesh(finGeometry, finMaterial);
                fin.position.x = -25;
                const angle = (i / 4) * Math.PI * 2;
                fin.position.y = Math.sin(angle) * 8;
                fin.position.z = Math.cos(angle) * 8;
                fin.rotation.z = angle;
                group.add(fin);
            }

            // Exhaust flame
            const exhaustGeometry = new THREE.ConeGeometry(4, 20, 8);
            const exhaustMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.8
            });
            this.exhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
            this.exhaust.position.x = -40;
            this.exhaust.rotation.z = Math.PI / 2;
            group.add(this.exhaust);

            this.mesh = group;
            this.mesh.position.copy(position);

            // Orient missile
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), direction);
            this.mesh.quaternion.copy(quaternion);

            // Add warning light
            this.warningLight = new THREE.PointLight(0xff0000, 5, 100);
            this.warningLight.position.copy(position);
            scene.add(this.warningLight);

            // Smoke trail particles
            this.smokeParticles = [];

            scene.add(this.mesh);

            // Find initial target
            this.findTarget();
        }

        findTarget() {
            let nearestDist = Infinity;
            let nearestShip = null;

            ships.forEach(ship => {
                if (ship !== this.owner && ship.alive) {
                    const dist = this.mesh.position.distanceTo(ship.mesh.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestShip = ship;
                    }
                }
            });

            this.target = nearestShip;
        }

        update() {
            this.lifetime++;

            // Check lifetime
            if (this.lifetime > this.maxLifetime) {
                this.explode();
                return false;
            }

            // Update target
            if (!this.target || !this.target.alive) {
                this.findTarget();
            }

            // Homing behavior
            if (this.target) {
                const toTarget = new THREE.Vector3();
                toTarget.subVectors(this.target.mesh.position, this.mesh.position);
                toTarget.normalize();

                // Smooth turning
                const turnSpeed = 0.02;
                this.velocity.lerp(toTarget.multiplyScalar(this.velocity.length()), turnSpeed);
            }

            // Apply velocity
            this.mesh.position.add(this.velocity);

            // Orient missile to face direction
            const lookAtPos = this.mesh.position.clone().add(this.velocity);
            this.mesh.lookAt(lookAtPos);
            this.mesh.rotateZ(Math.PI / 2);

            // Update warning light
            this.warningLight.position.copy(this.mesh.position);
            this.warningLight.intensity = 5 + Math.sin(Date.now() * 0.01) * 2;

            // Animate exhaust
            this.exhaust.scale.x = 1 + Math.random() * 0.3;
            this.exhaust.material.opacity = 0.6 + Math.random() * 0.4;

            // Create smoke trail
            if (this.lifetime % 2 === 0) {
                const smokeGeometry = new THREE.SphereGeometry(3 + Math.random() * 2, 8, 8);
                const smokeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x666666,
                    transparent: true,
                    opacity: 0.6
                });
                const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                smoke.position.copy(this.mesh.position);
                smoke.position.x -= 30;
                smoke.lifetime = 0;

                scene.add(smoke);
                this.smokeParticles.push(smoke);
            }

            // Update smoke particles
            this.smokeParticles = this.smokeParticles.filter(smoke => {
                smoke.lifetime++;
                smoke.scale.multiplyScalar(1.05);
                smoke.material.opacity *= 0.95;
                smoke.position.y += 0.5;

                if (smoke.material.opacity < 0.01 || smoke.lifetime > 60) {
                    scene.remove(smoke);
                    return false;
                }
                return true;
            });

            // Check for collision
            if (this.target) {
                const distance = this.mesh.position.distanceTo(this.target.mesh.position);
                if (distance < 50) {
                    this.explode();
                    return false;
                }
            }

            // Ground collision
            if (this.mesh.position.y < 10) {
                this.explode();
                return false;
            }

            return true;
        }

        explode() {
            // Nuclear explosion effect
            const explosionStages = [
                { radius: 50, color: 0xffffff, duration: 100 },
                { radius: 150, color: 0xffff00, duration: 200 },
                { radius: 300, color: 0xff6600, duration: 300 },
                { radius: 500, color: 0xff0000, duration: 400 }
            ];

            // Initial flash
            const flashGeometry = new THREE.SphereGeometry(100, 32, 32);
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 1
            });
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            flash.position.copy(this.mesh.position);
            scene.add(flash);

            // Mushroom cloud
            this.createMushroomCloud();

            // Shockwave
            const shockwaveGeometry = new THREE.RingGeometry(1, 10, 32);
            const shockwaveMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
            shockwave.position.copy(this.mesh.position);
            shockwave.rotation.x = -Math.PI / 2;
            scene.add(shockwave);

            // Damage calculation
            const blastRadius = 400;
            ships.forEach(ship => {
                if (ship.alive) {
                    const distance = this.mesh.position.distanceTo(ship.mesh.position);
                    if (distance < blastRadius) {
                        const damage = Math.max(0, (1 - distance / blastRadius) * 200);
                        ship.takeDamage(damage);

                        // Knock back
                        const knockback = new THREE.Vector3();
                        knockback.subVectors(ship.mesh.position, this.mesh.position);
                        knockback.normalize().multiplyScalar(20 * (1 - distance / blastRadius));
                        ship.velocity.add(knockback);
                    }
                }
            });

            // Animate explosion
            let frame = 0;
            const animateExplosion = () => {
                frame++;

                // Flash fade
                flash.scale.multiplyScalar(1.1);
                flashMaterial.opacity *= 0.9;

                // Shockwave expansion
                shockwave.scale.multiplyScalar(1.15);
                shockwave.material.opacity *= 0.95;

                if (frame < 100) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    scene.remove(flash);
                    scene.remove(shockwave);
                }
            };
            animateExplosion();

            // Play explosion sound
            if (sounds.explosion) {
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => sounds.explosion(), i * 100);
                }
            }

            // Clean up
            scene.remove(this.mesh);
            scene.remove(this.warningLight);
            this.smokeParticles.forEach(smoke => scene.remove(smoke));
        }

        createMushroomCloud() {
            const cloudGroup = new THREE.Group();
            cloudGroup.position.copy(this.mesh.position);

            // Stem
            const stemGeometry = new THREE.CylinderGeometry(30, 60, 200, 16);
            const stemMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.8
            });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = 100;
            cloudGroup.add(stem);

            // Cap
            const capGeometry = new THREE.SphereGeometry(100, 16, 16);
            const capMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.7
            });
            const cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.y = 200;
            cap.scale.y = 0.6;
            cloudGroup.add(cap);

            // Ring
            const ringGeometry = new THREE.TorusGeometry(80, 20, 8, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.6
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.y = 200;
            ring.rotation.x = Math.PI / 2;
            cloudGroup.add(ring);

            scene.add(cloudGroup);

            // Animate mushroom cloud
            let cloudFrame = 0;
            const animateCloud = () => {
                cloudFrame++;

                cloudGroup.position.y += 2;
                stem.scale.y *= 1.02;
                cap.scale.x *= 1.015;
                cap.scale.z *= 1.015;
                ring.scale.x *= 1.02;
                ring.scale.y *= 1.02;

                stemMaterial.opacity *= 0.98;
                capMaterial.opacity *= 0.98;
                ringMaterial.opacity *= 0.97;

                if (cloudFrame < 200 && stemMaterial.opacity > 0.01) {
                    requestAnimationFrame(animateCloud);
                } else {
                    scene.remove(cloudGroup);
                }
            };
            animateCloud();
        }

        destroy() {
            scene.remove(this.mesh);
            scene.remove(this.warningLight);
            this.smokeParticles.forEach(smoke => scene.remove(smoke));
        }
    }

    // Rocket class
    class Rocket {
        constructor(position, direction, owner) {
            this.owner = owner;
            this.damage = 50;
            this.velocity = direction.multiplyScalar(15);
            this.lifetime = 0;
            this.maxLifetime = 120;

            // Create rocket model
            const group = new THREE.Group();

            // Rocket body
            const bodyGeometry = new THREE.CylinderGeometry(2, 3, 20, 6);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0xff6600,
                emissive: 0xff3300,
                emissiveIntensity: 0.5
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.z = Math.PI / 2;
            group.add(body);

            // Rocket tip
            const tipGeometry = new THREE.ConeGeometry(3, 8, 6);
            const tipMaterial = new THREE.MeshPhongMaterial({
                color: 0xffaa00,
                emissive: 0xff6600,
                emissiveIntensity: 0.7
            });
            const tip = new THREE.Mesh(tipGeometry, tipMaterial);
            tip.position.x = 14;
            tip.rotation.z = -Math.PI / 2;
            group.add(tip);

            // Exhaust
            const exhaustGeometry = new THREE.ConeGeometry(2.5, 10, 6);
            const exhaustMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.8
            });
            this.exhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
            this.exhaust.position.x = -15;
            this.exhaust.rotation.z = Math.PI / 2;
            group.add(this.exhaust);

            this.mesh = group;
            this.mesh.position.copy(position);

            // Orient rocket
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), direction);
            this.mesh.quaternion.copy(quaternion);

            scene.add(this.mesh);
        }

        update() {
            this.lifetime++;
            this.mesh.position.add(this.velocity);

            // Animate exhaust
            this.exhaust.scale.x = 1 + Math.random() * 0.5;
            this.exhaust.material.opacity = 0.6 + Math.random() * 0.4;

            // Create smoke trail
            if (this.lifetime % 3 === 0) {
                const smokeGeometry = new THREE.SphereGeometry(1.5, 6, 6);
                const smokeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x666666,
                    transparent: true,
                    opacity: 0.4
                });
                const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                smoke.position.copy(this.mesh.position);
                scene.add(smoke);

                // Animate smoke
                const animateSmoke = () => {
                    smoke.scale.multiplyScalar(1.1);
                    smoke.material.opacity *= 0.9;
                    smoke.position.y += 0.3;
                    if (smoke.material.opacity > 0.01) {
                        requestAnimationFrame(animateSmoke);
                    } else {
                        scene.remove(smoke);
                    }
                };
                animateSmoke();
            }

            // Check boundaries
            if (this.mesh.position.length() > CONFIG.ARENA_SIZE * 1.5 || this.lifetime > this.maxLifetime) {
                this.destroy();
                return false;
            }

            // Check collisions
            for (let ship of ships) {
                if (ship !== this.owner && ship.alive) {
                    const distance = this.mesh.position.distanceTo(ship.mesh.position);
                    if (distance < 40) {
                        ship.takeDamage(this.damage);
                        if (!ship.alive && this.owner) {
                            this.owner.kills++;
                            this.owner.score += 100;
                        }
                        this.explode();
                        return false;
                    }
                }
            }

            return true;
        }

        explode() {
            // Small explosion effect
            const explosionGeometry = new THREE.SphereGeometry(30, 8, 8);
            const explosionMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 1
            });
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosion.position.copy(this.mesh.position);
            scene.add(explosion);

            // Animate explosion
            const animateExplosion = () => {
                explosion.scale.multiplyScalar(1.15);
                explosionMaterial.opacity *= 0.85;
                if (explosionMaterial.opacity > 0.01) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    scene.remove(explosion);
                }
            };
            animateExplosion();

            playSound('explosion');
            this.destroy();
        }

        destroy() {
            scene.remove(this.mesh);
        }
    }

    // Laser class
    class Laser {
        constructor(position, direction, color, owner, damage = CONFIG.DAMAGE, speed = CONFIG.LASER_SPEED) {
            this.owner = owner;
            this.damage = damage;
            this.velocity = direction.multiplyScalar(speed);

            const geometry = new THREE.CylinderGeometry(0.8, 0.8, 40);  // Bigger laser
            const material = new THREE.MeshBasicMaterial({
                color: color,
                emissive: color
            });
            this.mesh = new THREE.Mesh(geometry, material);
            this.mesh.position.copy(position);

            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
            this.mesh.quaternion.copy(quaternion);

            scene.add(this.mesh);
        }

        update() {
            this.mesh.position.add(this.velocity);

            // Check boundaries
            if (this.mesh.position.length() > CONFIG.ARENA_SIZE * 1.5) {
                this.destroy();
                return false;
            }

            // Check collisions
            for (let ship of ships) {
                if (ship !== this.owner && ship.alive) {
                    const distance = this.mesh.position.distanceTo(ship.mesh.position);
                    if (distance < 40) {  // Increased from 10 to 40 for bigger ships
                        ship.takeDamage(this.damage);
                        if (!ship.alive && this.owner) {
                            this.owner.kills++;
                            this.owner.score += 100;
                        }
                        this.destroy();
                        return false;
                    }
                }
            }

            return true;
        }

        destroy() {
            scene.remove(this.mesh);
        }
    }

    // Ship class
    class Ship {
        constructor(config, index) {
            this.config = config || { name: 'AI', color: 0xff0000, emissive: 0xff0000 };
            this.name = this.config.name;
            this.health = CONFIG.SHIP_HP;
            this.shield = CONFIG.SHIELD_HP;
            this.alive = true;
            this.velocity = new THREE.Vector3();
            this.target = null;
            this.lastShot = 0;
            this.score = 0;
            this.kills = 0;
            this.isPlayer = false;

            this.createModel();

            // Position ships facing each other for 2 ships
            if (CONFIG.SHIPS === 2) {
                if (index === 0) {
                    this.mesh.position.set(-300, 200, 0);
                    this.mesh.rotation.y = Math.PI / 2;  // Face right
                } else {
                    this.mesh.position.set(300, 200, 0);
                    this.mesh.rotation.y = -Math.PI / 2;  // Face left
                }
            } else {
                // Original circular positioning for more ships
                const angle = (Math.PI * 2 * index) / CONFIG.SHIPS;
                this.mesh.position.x = Math.cos(angle) * CONFIG.ARENA_SIZE * 0.9;
                this.mesh.position.z = Math.sin(angle) * CONFIG.ARENA_SIZE * 0.9;
                this.mesh.position.y = 150 + (index % 3) * 50;
            }
        }

        createModel() {
            const group = new THREE.Group();

            // Fighter jet body - MUCH LARGER
            const bodyGeometry = new THREE.CylinderGeometry(4, 12, 80, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: this.config.color,
                emissive: this.config.emissive,
                emissiveIntensity: 0.5
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.z = Math.PI / 2;
            group.add(body);

            // Wings - MUCH WIDER
            const wingGeometry = new THREE.BoxGeometry(120, 2, 32);
            const wingMaterial = new THREE.MeshPhongMaterial({
                color: this.config.color,
                emissive: this.config.emissive,
                emissiveIntensity: 0.3
            });
            const wings = new THREE.Mesh(wingGeometry, wingMaterial);
            wings.position.x = -8;
            group.add(wings);

            // Cockpit - BIGGER
            const cockpitGeometry = new THREE.SphereGeometry(8, 8, 6);
            const cockpitMaterial = new THREE.MeshPhongMaterial({
                color: 0x333333,
                transparent: true,
                opacity: 0.8
            });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.x = 28;
            group.add(cockpit);

            // Tail fin - LARGER
            const tailGeometry = new THREE.BoxGeometry(2, 32, 20);
            const tailMaterial = new THREE.MeshPhongMaterial({
                color: this.config.color,
                emissive: this.config.emissive,
                emissiveIntensity: 0.3
            });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.x = -32;
            tail.position.y = 12;
            group.add(tail);

            // Engines - BIGGER
            for (let i = -1; i <= 1; i += 2) {
                const engineGeometry = new THREE.CylinderGeometry(6, 4, 32, 8);
                const engineMaterial = new THREE.MeshPhongMaterial({
                    color: 0x444444,
                    emissive: this.config.emissive,
                    emissiveIntensity: 0.3
                });
                const engine = new THREE.Mesh(engineGeometry, engineMaterial);
                engine.position.x = -24;
                engine.position.y = i * 12;
                engine.rotation.z = Math.PI / 2;
                group.add(engine);

                // Afterburner
                const afterburnerGeometry = new THREE.ConeGeometry(4.8, 24, 8);
                const afterburnerMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0
                });
                const afterburner = new THREE.Mesh(afterburnerGeometry, afterburnerMaterial);
                afterburner.position.x = -40;
                afterburner.position.y = i * 12;
                afterburner.rotation.z = -Math.PI / 2;
                group.add(afterburner);

                if (i === -1) {
                    this.afterburner1 = afterburner;
                } else {
                    this.afterburner2 = afterburner;
                }
            }

            this.mesh = group;
            scene.add(this.mesh);
        }

        update() {
            if (!this.alive) return;

            // AI movement
            if (!this.isPlayer) {
                // Find nearest enemy
                let nearestDist = Infinity;
                ships.forEach(ship => {
                    if (ship !== this && ship.alive) {
                        const dist = this.mesh.position.distanceTo(ship.mesh.position);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            this.target = ship;
                        }
                    }
                });

                // Move towards target with collision consideration
                if (this.target) {
                    const distance = this.mesh.position.distanceTo(this.target.mesh.position);
                    const direction = new THREE.Vector3();
                    direction.subVectors(this.target.mesh.position, this.mesh.position);
                    direction.normalize();

                    // Only move closer if not too close
                    if (distance > 100) {
                        this.velocity.add(direction.multiplyScalar(0.5));
                    } else {
                        // Circle around target if too close
                        const tangent = new THREE.Vector3(-direction.z, 0, direction.x);
                        this.velocity.add(tangent.multiplyScalar(0.3));
                    }

                    this.mesh.lookAt(this.target.mesh.position);

                    // Shoot at longer range
                    if (nearestDist < 400 && nearestDist > 80 && Date.now() - this.lastShot > 500) {
                        this.fire();
                    }
                }
            }

            // Apply velocity with collision avoidance
            const maxSpeed = CONFIG.SHIP_SPEED;
            if (this.velocity.length() > maxSpeed) {
                this.velocity.normalize().multiplyScalar(maxSpeed);
            }

            // Collision avoidance with other ships
            this.avoidCollisions();

            this.mesh.position.add(this.velocity);
            this.velocity.multiplyScalar(0.95);

            // Boundaries
            const boundary = CONFIG.ARENA_SIZE;
            ['x', 'z'].forEach(axis => {
                if (Math.abs(this.mesh.position[axis]) > boundary) {
                    this.mesh.position[axis] = Math.sign(this.mesh.position[axis]) * boundary;
                    this.velocity[axis] *= -0.8;
                }
            });

            // Height limits
            if (this.mesh.position.y < CONFIG.MIN_HEIGHT) {
                this.mesh.position.y = CONFIG.MIN_HEIGHT;
                this.velocity.y = Math.abs(this.velocity.y) * 0.8;
            }
            if (this.mesh.position.y > CONFIG.MAX_HEIGHT) {
                this.mesh.position.y = CONFIG.MAX_HEIGHT;
                this.velocity.y = -Math.abs(this.velocity.y) * 0.8;
            }
        }

        fire() {
            this.lastShot = Date.now();

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(this.mesh.quaternion);

            const laser = new Laser(this.mesh.position, direction, this.config.color, this);
            lasers.push(laser);

            // Muzzle flash
            const flash = new THREE.PointLight(this.config.color, 3, 50);
            flash.position.copy(this.mesh.position);
            scene.add(flash);
            setTimeout(() => scene.remove(flash), 100);
        }

        avoidCollisions() {
            const avoidanceRadius = 80; // Distance to start avoiding
            const separationForce = 5; // Strength of avoidance

            ships.forEach(otherShip => {
                if (otherShip !== this && otherShip.alive) {
                    const distance = this.mesh.position.distanceTo(otherShip.mesh.position);

                    if (distance < avoidanceRadius && distance > 0) {
                        // Calculate avoidance vector
                        const avoidVector = new THREE.Vector3();
                        avoidVector.subVectors(this.mesh.position, otherShip.mesh.position);
                        avoidVector.normalize();

                        // Stronger force when closer
                        const strength = (avoidanceRadius - distance) / avoidanceRadius;
                        avoidVector.multiplyScalar(separationForce * strength);

                        // Apply avoidance force
                        this.velocity.add(avoidVector);

                        // Add vertical separation if too close
                        if (distance < 60) {
                            // Move up or down based on relative position
                            if (this.mesh.position.y > otherShip.mesh.position.y) {
                                this.velocity.y += 2;
                            } else {
                                this.velocity.y -= 2;
                            }
                        }
                    }
                }
            });
        }

        takeDamage(amount) {
            if (this.shield > 0) {
                this.shield -= amount;
                if (this.shield < 0) {
                    this.health += this.shield;
                    this.shield = 0;
                }
            } else {
                this.health -= amount;
            }

            if (this.health <= 0) {
                this.alive = false;
                this.destroy();
            }

            // Update HUD if player
            if (this.isPlayer) {
                const healthBar = document.getElementById('playerHealthBar');
                const shieldBar = document.getElementById('playerShieldBar');
                if (healthBar) healthBar.style.width = this.health + '%';
                if (shieldBar) shieldBar.style.width = this.shield + '%';
            }
        }

        destroy() {
            // Explosion effect - BIGGER
            const explosionGeometry = new THREE.SphereGeometry(80, 16, 16);
            const explosionMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 1
            });
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosion.position.copy(this.mesh.position);
            scene.add(explosion);

            // Create debris
            for (let i = 0; i < 30; i++) {
                const debrisGeometry = new THREE.BoxGeometry(
                    Math.random() * 8 + 2,
                    Math.random() * 8 + 2,
                    Math.random() * 8 + 2
                );
                const debrisMaterial = new THREE.MeshPhongMaterial({
                    color: Math.random() > 0.5 ? this.config.color : 0x666666
                });
                const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
                debris.position.copy(this.mesh.position);
                debris.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 40,
                    (Math.random() - 0.5) * 40,
                    (Math.random() - 0.5) * 40
                );
                debris.angularVelocity = new THREE.Vector3(
                    Math.random() * 0.5,
                    Math.random() * 0.5,
                    Math.random() * 0.5
                );
                scene.add(debris);

                // Animate debris
                const animateDebris = () => {
                    debris.position.add(debris.velocity);
                    debris.rotation.x += debris.angularVelocity.x;
                    debris.rotation.y += debris.angularVelocity.y;
                    debris.rotation.z += debris.angularVelocity.z;
                    debris.velocity.y -= 0.5; // Gravity

                    if (debris.position.y < -100) {
                        scene.remove(debris);
                    } else {
                        requestAnimationFrame(animateDebris);
                    }
                };
                animateDebris();
            }

            // Animate explosion
            const animateExplosion = () => {
                explosion.scale.multiplyScalar(1.1);
                explosionMaterial.opacity *= 0.9;
                if (explosionMaterial.opacity > 0.01) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    scene.remove(explosion);
                }
            };
            animateExplosion();

            scene.remove(this.mesh);
        }
    }

    // Player Ship class
    class PlayerShip extends Ship {
        constructor() {
            const playerConfig = {
                name: 'PLAYER',
                color: 0x00ff00,
                emissive: 0x00ff00
            };
            super(playerConfig, -1);

            this.mesh.position.set(0, 150, 300);  // Higher and farther back
            this.isPlayer = true;
            this.keys = {
                up: false,
                down: false,
                left: false,
                right: false,
                fire: false,
                boost: false,
                special: false,
                switchWeapon: false
            };

            this.weaponType = 'PLASMA';
            this.ammo = 100;
            this.specialWeaponReady = true;
            this.specialCooldown = 0;

            // Weapon system
            this.weapons = ['PLASMA', 'LASER', 'ROCKETS'];
            this.currentWeaponIndex = 0;
            this.weaponStats = {
                'PLASMA': { damage: 20, fireRate: 200, speed: 25, color: 0x00ff00 },
                'LASER': { damage: 10, fireRate: 100, speed: 40, color: 0x00ffff },
                'ROCKETS': { damage: 50, fireRate: 800, speed: 15, color: 0xff6600 }
            };
        }

        update() {
            if (!this.alive) return;

            // Movement
            if (this.keys.up) {
                this.mesh.rotation.x = Math.max(this.mesh.rotation.x - 0.02, -Math.PI / 4);
            }
            if (this.keys.down) {
                this.mesh.rotation.x = Math.min(this.mesh.rotation.x + 0.02, Math.PI / 4);
            }
            if (this.keys.left) {
                this.mesh.rotation.z = Math.min(this.mesh.rotation.z + 0.03, Math.PI / 3);
                this.mesh.rotation.y += 0.025;
            }
            if (this.keys.right) {
                this.mesh.rotation.z = Math.max(this.mesh.rotation.z - 0.03, -Math.PI / 3);
                this.mesh.rotation.y -= 0.025;
            }

            // Auto-level roll
            if (!this.keys.left && !this.keys.right) {
                this.mesh.rotation.z *=1

            }

            // Suite du code PlayerShip.update()
            // Auto-level roll
            if (!this.keys.left && !this.keys.right) {
                this.mesh.rotation.z *= 0.95;
            }

            // Speed with collision avoidance
            const speed = this.keys.boost ? CONFIG.BOOST_SPEED : CONFIG.SHIP_SPEED;
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(this.mesh.quaternion);
            this.velocity = direction.multiplyScalar(speed);

            // Apply collision avoidance
            this.avoidCollisions();

            // Apply movement
            this.mesh.position.add(this.velocity.clone().multiplyScalar(0.1));

            // Boundaries
            const boundary = CONFIG.ARENA_SIZE;
            ['x', 'z'].forEach(axis => {
                if (Math.abs(this.mesh.position[axis]) > boundary) {
                    this.mesh.position[axis] = Math.sign(this.mesh.position[axis]) * boundary;
                    this.velocity[axis] *= -0.8;
                    this.takeDamage(5);
                }
            });

            // Height limits
            if (this.mesh.position.y < CONFIG.MIN_HEIGHT) {
                this.mesh.position.y = CONFIG.MIN_HEIGHT;
                this.velocity.y = Math.abs(this.velocity.y) * 0.8;
            }
            if (this.mesh.position.y > CONFIG.MAX_HEIGHT) {
                this.mesh.position.y = CONFIG.MAX_HEIGHT;
                this.velocity.y = -Math.abs(this.velocity.y) * 0.8;
            }

            // Fire
            if (this.keys.fire && Date.now() - this.lastShot > this.weaponStats[this.weaponType].fireRate) {
                this.fire();
            }

            // Special weapon (Nuclear Missile)
            if (this.keys.special && this.specialWeaponReady) {
                this.fireNuclearMissile();
            }

            // Switch weapon
            if (this.keys.switchWeapon && !this.weaponSwitchCooldown) {
                this.switchWeapon();
                this.weaponSwitchCooldown = true;
                setTimeout(() => { this.weaponSwitchCooldown = false; }, 300);
            }

            // Update special cooldown
            if (!this.specialWeaponReady) {
                this.specialCooldown--;
                if (this.specialCooldown <= 0) {
                    this.specialWeaponReady = true;
                    document.getElementById('specialReady').textContent = 'READY';
                    document.getElementById('specialReady').classList.add('special-ready');
                } else {
                    const seconds = Math.ceil(this.specialCooldown / 60);
                    document.getElementById('specialReady').textContent = `${seconds}s`;
                    document.getElementById('specialReady').classList.remove('special-ready');
                }
            }

            // Update score
            this.score = this.kills * 100;
            if (document.getElementById('playerScore')) {
                document.getElementById('playerScore').textContent = this.score;
            }
        }

        switchWeapon() {
            this.currentWeaponIndex = (this.currentWeaponIndex + 1) % this.weapons.length;
            this.weaponType = this.weapons[this.currentWeaponIndex];

            // Update UI
            document.getElementById('playerWeapon').textContent = this.weaponType;

            // Visual feedback
            showNotification(`Weapon: ${this.weaponType}`);
            playSound('powerup');
        }

        fire() {
            this.lastShot = Date.now();

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(this.mesh.quaternion);

            const weaponData = this.weaponStats[this.weaponType];

            if (this.weaponType === 'ROCKETS') {
                // Fire rocket projectile
                const rocket = new Rocket(this.mesh.position.clone(), direction, this);
                lasers.push(rocket);
            } else {
                // Fire regular laser
                const laser = new Laser(
                    this.mesh.position,
                    direction,
                    weaponData.color,
                    this,
                    weaponData.damage,
                    weaponData.speed
                );
                lasers.push(laser);
            }

            // Muzzle flash
            const flash = new THREE.PointLight(weaponData.color, 3, 50);
            flash.position.copy(this.mesh.position);
            scene.add(flash);
            setTimeout(() => scene.remove(flash), 100);

            playSound('shoot');
        }

        fireNuclearMissile() {
            this.specialWeaponReady = false;
            this.specialCooldown = 600; // 10 seconds cooldown

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(this.mesh.quaternion);

            const missile = new NuclearMissile(this.mesh.position.clone(), direction, this);
            missiles.push(missile);

            // Visual and audio feedback
            showNotification('☢️ NUCLEAR MISSILE LAUNCHED!');
            playSound('powerup');

            // Screen shake effect
            const originalCameraPos = camera.position.clone();
            let shakeFrames = 30;
            const shakeCamera = () => {
                if (shakeFrames > 0) {
                    camera.position.x = originalCameraPos.x + (Math.random() - 0.5) * 10;
                    camera.position.y = originalCameraPos.y + (Math.random() - 0.5) * 10;
                    shakeFrames--;
                    requestAnimationFrame(shakeCamera);
                }
            };
            shakeCamera();
        }

        destroy() {
            super.destroy();

            // Game over for player
            document.getElementById('winnerName').textContent = 'GAME OVER';
            document.getElementById('winnerName').style.color = '#ff0000';
            document.getElementById('winnerStats').innerHTML = `
            Your Score: ${this.score}<br>
            Eliminations: ${this.kills}
        `;
            document.getElementById('restartText').style.display = 'none';
            document.getElementById('menuButtons').style.display = 'block';
            document.getElementById('winnerOverlay').style.display = 'flex';
        }
    }

    // Game functions
    function startBattle() {
        timer = CONFIG.BATTLE_TIME;
        ships = [];
        lasers = [];
        missiles = [];
        powerups = [];
        gameState = 'battle';
        playerShip = null;

        // Create player ship
        if (gameMode === 'player' || gameMode === 'mixed') {
            playerShip = new PlayerShip();
            ships.push(playerShip);
            setupPlayerControls();
        }

        // Create AI ships
        const aiCount = gameMode === 'player' ? 1 : (gameMode === 'mixed' ? 1 : 2);  // Max 2 ships total
        for (let i = 0; i < aiCount; i++) {
            const config = {
                name: `AI-${i + 1}`,
                color: Math.random() * 0xffffff,
                emissive: Math.random() * 0xffffff
            };
            const ship = new Ship(config, i);
            ships.push(ship);
        }

        gameLoop();
    }

    function gameLoop() {
        if (gameState !== 'battle') return;

        timer--;
        updateHUD();

        const alive = ships.filter(s => s.alive);

        // Check end conditions
        if (gameMode === 'player' || gameMode === 'mixed') {
            if (playerShip && !playerShip.alive) {
                gameState = 'ended';
                return;
            }
        }

        if (alive.length <= 1 || timer <= 0) {
            endBattle();
            return;
        }

        setTimeout(gameLoop, 1000);
    }

    function endBattle() {
        gameState = 'ended';

        const alive = ships.filter(s => s.alive);
        const winner = alive.length > 0 ? alive[0] : ships[0];

        if (gameMode === 'ai' || (winner && !winner.isPlayer)) {
            document.getElementById('winnerName').textContent = winner.name;
            document.getElementById('winnerName').style.color = '#' + winner.config.color.toString(16).padStart(6, '0');
            document.getElementById('winnerStats').innerHTML = `
            Score: ${winner.score}<br>
            Eliminations: ${winner.kills}
        `;
            document.getElementById('restartText').style.display = 'block';
            document.getElementById('menuButtons').style.display = 'none';
            document.getElementById('winnerOverlay').style.display = 'flex';

            // Auto restart for AI mode
            if (gameMode === 'ai') {
                let countdown = 5;
                const countInterval = setInterval(() => {
                    countdown--;
                    document.getElementById('countdown').textContent = countdown;
                    if (countdown <= 0) {
                        clearInterval(countInterval);
                        document.getElementById('winnerOverlay').style.display = 'none';
                        cleanupBattle();
                        startBattle();
                    }
                }, 1000);
            }
        }
    }

    function cleanupBattle() {
        ships.forEach(ship => {
            if (ship.mesh) scene.remove(ship.mesh);
        });
        lasers.forEach(laser => {
            scene.remove(laser.mesh);
        });
        missiles.forEach(missile => {
            missile.destroy();
        });
        ships = [];
        lasers = [];
        missiles = [];
    }

    function updateHUD() {
        const alive = ships.filter(s => s.alive);
        document.getElementById('aliveCount').textContent = alive.length;

        const minutes = Math.floor(timer / 60);
        const seconds = timer % 60;
        document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    // Player controls
    function setupPlayerControls() {
        // Desktop controls
        document.addEventListener('keydown', (e) => {
            if (!playerShip || !playerShip.alive) return;

            switch(e.key) {
                case 'ArrowUp': playerShip.keys.up = true; e.preventDefault(); break;
                case 'ArrowDown': playerShip.keys.down = true; e.preventDefault(); break;
                case 'ArrowLeft': playerShip.keys.left = true; e.preventDefault(); break;
                case 'ArrowRight': playerShip.keys.right = true; e.preventDefault(); break;
                case ' ': playerShip.keys.fire = true; e.preventDefault(); break;
                case 'Shift': playerShip.keys.boost = true; e.preventDefault(); break;
                case 'e':
                case 'E': playerShip.keys.special = true; e.preventDefault(); break;
                case 'q':
                case 'Q':
                    if (!playerShip.weaponSwitchCooldown) {
                        playerShip.keys.switchWeapon = true;
                        e.preventDefault();
                    }
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (!playerShip || !playerShip.alive) return;

            switch(e.key) {
                case 'ArrowUp': playerShip.keys.up = false; break;
                case 'ArrowDown': playerShip.keys.down = false; break;
                case 'ArrowLeft': playerShip.keys.left = false; break;
                case 'ArrowRight': playerShip.keys.right = false; break;
                case ' ': playerShip.keys.fire = false; break;
                case 'Shift': playerShip.keys.boost = false; break;
                case 'e':
                case 'E': playerShip.keys.special = false; break;
                case 'q':
                case 'Q': playerShip.keys.switchWeapon = false; break;
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && gameState === 'battle') {
                togglePause();
            }
        });
    }

    // Animation loop
    function animate() {
        requestAnimationFrame(animate);

        // Update camera
        const time = Date.now() * 0.0001;
        if (gameMode === 'player' && playerShip && playerShip.alive) {
            // Follow player - Further back for bigger ship
            const offset = new THREE.Vector3(0, 30, 80);
            offset.applyQuaternion(playerShip.mesh.quaternion);
            camera.position.copy(playerShip.mesh.position).add(offset);

            const lookAt = new THREE.Vector3(0, 0, -100);
            lookAt.applyQuaternion(playerShip.mesh.quaternion);
            lookAt.add(playerShip.mesh.position);
            camera.lookAt(lookAt);
        } else {
            // Orbital camera - Further out
            camera.position.x = Math.cos(time) * 600;
            camera.position.z = Math.sin(time) * 600;
            camera.position.y = 300 + Math.sin(time * 2) * 100;
            camera.lookAt(0, 100, 0);
        }

        // Update game objects
        if (gameState === 'battle') {
            ships.forEach(ship => ship.update());
            lasers = lasers.filter(laser => laser.update());
            missiles = missiles.filter(missile => missile.update());
        }

        renderer.render(scene, camera);
    }

    // Handle resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start game
    window.addEventListener('load', init);


</script>